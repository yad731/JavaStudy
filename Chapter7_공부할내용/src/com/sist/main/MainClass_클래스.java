package com.sist.main;
/*
	0) 변수(데이터형), 연산자, 제어문, 배열 (2~5장)
	
	1) 클래스
		= 클래스 정의하는 방법 (객체지향 프로그램 => 클래스와 클래스의 연관관계)
			*** 접근지정어
				- 클래스 : public => 메모리 할당용
				- 메소드 : public => 다른 클래스와 통신을 담당 (기능)
				- 변수 : private => 데이터 보호
				- 생성자 : public => 메모리 할당
					=> 대상 분석 (요구사항 분석) => 변수/메소드
			class ClassName
			{
				----------------------------------
				  속성, 필드 ==> 멤버변수(캡슐화) ==> getter/setter (변수 : 읽기/쓰기) = 인스턴스 변수
				   ** 공유하는 변수 (static)
				   ** 변수는 기본형만 있는 것이 아니다 (배열, 클래스)
				----------------------------------
				  생성자 : 오버로딩 (여러 개 가능) => 변수에 대한 초기화
				  		 생성자가 없는 경우 => 자동으로 default 생성자(매개변수가 없음) 추가
				----------------------------------
				  메소드 : 기능 처리 (속성, 필드)를 제어한다
				  		 클래스 내 속성, 필드와 관련이 없는 경우 static 메소드 사용
				  		 
				  		 String s = "Hello Java";
				  		 s가 가지고 있는 문자 개수 => s.length()		// 인스턴스 메소드
				  		 String.valueOf(10);					// 변수 s와 관련 없음 (값을 제어하지 않음) => static 메소드
				----------------------------------
			}
		= 객체 생성하는 방법 (new)
			클래스(사용자 데이터형)
			기본형 ==> 메모리 자체에 값을 설정				// stack 메모리
			참조형 ==> 메모리에 참조할 주소값을 설정	(new)	// heap 메모리
					 클래스명 참조변수 = new 생성자()
					 		----- 객체, 인스턴스
					 클래스명 참조변수 = 클래스명.newInstance()
					 클래스명 참조변수 = Class.forName().getInstance()
		= 메소드 정의하는 방법
			[접근지정어][제어어] 리턴형 메소드명(매개변수...)		<== 선언부
			public static : 객체마다 공통으로 사용되는 메소드 (데이터베이스)
			public final : 종단 메소드 (오버라이딩 불가) (사용빈도 낮다)
			public abstract : 선언만 하는 메소드 => 프로그램에 맞게 구현해서 사용 (추상클래스 / 인터페이스)
			{
				구현부
			}
		= 생성자 정의하는 방법 (291page)
			특징
				1) 클래스명과 동일
				2) 리턴형이 없다 (리턴형이 있는 경우 : 일반 인스턴스메소드)
				3) 변수의 초기화, 메모리에 저장 시 호출되는 메소드
					변수의 초기화 : 시작과 동시에 수행하는 기능(웹, 윈도우 등의 화면 UI)이 있는 경우
								 자동 로그인, 쿠키, 윈도우 화면 디자인, 데이터베이스 연결, 서버 연결 ...
								 프로그램 구동 시 첫번째로 호출되는 메소드
				4) 오버로딩
					초기화 => 직접 초기화(매개변수가 없는 경우), 사용자로부터 받아서 초기화(매개변수)
					오버로딩(생성자)
					 => 메소드명이 동일
					 => 매개변수가 다르다 (개수, 데이터형)
					 => 리턴형은 관계없다
					 	method()	================================> method()
					 	method(int a)	============================> method(int) 		// 데이터형만 저장하기 때문에
					 	method(int b)	============================> method(int) 		// 매개변수명은 상관없다
					 	method(int a, int b)		================> method(int, int)
					 	****같은 메소드명을 이용해서 다른 기능을 추가할 때 사용
		= this 키워드 : 객체 자신을 나타내는 키워드
			생성자와 인스턴스 메소드에서만 사용이 가능 (static 메소드는 this가 없다)
			class A
			{
				public A(/*A this : 생략되어 보이지 않음*\){}
				public void display(A this){}
				public static void aaa(){}
			}
			A a = new A();
			a.display();
			
			this의 특징 => static Object this;
			this 생성 => 객체 생성 시에 저장 => 생성된 객체의 주소
			A a = new A();
			==> 컴파일러 (this = a)
			A b = new A();
			==> 컴파일러 (this = b)
			
			this는 자신의 객체를 전송하고 지역변수와 구분한다
				자신의 객체 전송 : 윈도우 (new를 계속 생성하며 새로운 창을 계속해서 띄우지 않고 this를 사용하여 기존 창에 결과값을 출력)
				
				
				
	2) 상속 => 객체지향의 특성
				- 데이터보호 : 캡슐화
				- 재사용 : 상속/포함
				- 수정/추가 : 다형성(오버라이딩/오버로딩)
				- 공통적인 내용을 모아서 모듈화 : 추상화
				* 문법이 아닌 권장사항
					class A
					{
						글쓰기()
						상세보기()
						목록출력()
						수정()
						삭제()
						검색()
					}
					class B
					{
						글쓰기()
						상세보기()
						목록출력()
						수정()
						삭제()
						검색()
						답변()
					}				===> 가능한...
					class C extends A
					{
						답변()
					}
					class D
					{
						A a = new A();		==> 상속을 받지 않고 클래스 안에 클래스 객체를 만들어버림 => but 변경해서 사용하기 어렵다...
						답변()
					}
			상속(기능을 변경)
				사용자 정의 클래스
			포함(기능 변경이 없는 경우)
				라이브러리
		= 자바 상속의 특징
			= 재사용이 가능
			= 반복 코딩을 제거
			= 기본의 클래스를 확장해서 새로운 클래스 제작 => 개발자가 수정해서 사용이 가능 (오버라이딩)
			= 유지보수
			= 상속 : extends (확장된 개념)
			= 단일 상속만 가능하다
			= 상속내리는 클래스 > 상속받는 클래스 => 상속이 있는 경우에만 클래스의 크기를 비교할 수 있다 (형변환)
				class Super
				class Sub extends Super
				==> 메모리 할당 (Sub를 사용)
						Super
							int a
							int b
							aaa()
							bbb()
						Sub extends Super
							int c
							ccc()
					1) 상위 클래스로 생성 (추상클래스, 인터페이스 => 자신이 메모리 할당을 할 수 없어서)
						Super s = new Sub();
							====> s.a, s.b, s.aaa(), s.bbb()	// 4개 사용 가능
								  --Super-- -------Sub------	// 변수는 클래스를, 메소드는 생성자를 따라간다
					2) 하위 클래스로 생성 *** 기본
						Sub s = new Sub();
					3) 상위 클래스로 생성, 하위 클래스로 받는다
						Sub s = (Sub)new Super();
		= super 키워드 : 상위 클래스를 제어 (변수값 변경, 메소드를 호출 시에 주로 사용)
		= 메소드 오버라이딩
			=> 추상 클래스 / 인터페이스 (선언)
			1) 메소드명 동일
			2) 매개변수 동일
			3) 리턴형 동일
			4) 접근지정어는 확대 가능 (public)
		= final 키워드
			final => 상수형 변수
			static final => 상수
			1) 반드시 초기화를 한다
			2) 지역변수에서도 사용이 가능
			3) 변수는 대문자로 사용한다
			4) 변경할 수 없다
		= Object 클래스 : 모든 클래스의 상위 클래스
						(라이브러리, 사용자 정의 클래스)
		
	3) 인터페이스 / 추상클래스
		= 인터페이스 / 추상클래스의 차이점
			목적)
				추상클래스 : 상속을 받아 확장
				인터페이스 : 관련된 여러 개의 클래스를 묶어서 관리 (메소드가 동일)
				-----------------------------------------------------
							추상 클래스				인터페이스
				-----------------------------------------------------
				 	자신이 메모리 할당을 할 수 없다 (상속을 통한 구현 후에 사용)
				 				=> 하위 클래스를 이용하여 처리
				-----------------------------------------------------
				 상속			단일 상속					다중 상속
				-----------------------------------------------------
				메소드	   	구현된 메소드				구현되지 않은 메소드
						   	구현되지 않은 메소드			JDK 1.8 ~ => 구현된 메소드 가능
				-----------------------------------------------------
				 변수			인스턴스변수가 존재			인스턴스변수가 없다
				 									상수형 변수만 설정 가능
				-----------------------------------------------------
				생성자		존재						존재하지 않는다
				-----------------------------------------------------
				상속키워드		extends					implements
				-----------------------------------------------------
				접근지정어		전체 사용					public
				-----------------------------------------------------
		= 인터페이스 / 추상클래스의 정의
			추상클래스
				public abstract class ClassName
				{
					변수 설정 (인스턴스, static)
					생성자 설정
					구현된 메소드
					구현되지 않은 메소드 (추상메소드) : 공통으로 사용되는 기능
												예) 마우스
													=> 마우스 클릭, 마우스 이동, 마우스 드래그, 마우스 올리기, 마우스 내리기
												   버튼
												   	=> 클릭, 더블 클릭
												=> 프로그램마다 사용 방법이 다르다 (구현이 되지 않은 상태로 선언)
												public abstract 리턴형 메소드명(매개변수...);		==> 추상메소드
				}
			인터페이스 : 추상클래스의 단점 보완 (=> 실제 프로그램에서 인터페이스가 더 많이 사용)
				public interface interfaceName
				{
					상수 설정
						반드시 선언과 함께 값을 부여해야
						(public static final) int a = 10;		// public static final 없이 적어도 무방, 컴파일러가 자동으로 추가
					구현되지 않은 메소드
						(public abstract) void display();		// public abstract가 모든 메소드 앞에 
					구현된 메소드
						(public) default void aaa(){}			// default는 반드시 직접 추가
				}
		= 인터페이스 / 추상클래스 구현방법
			추상클래스
				abstract class A
					{ aaa(), bbb(), abstract ccc()}
				==> class B extends A
					{
						// 반드시 구현해야 하는 부분
						추상메소드(구현이 되지 않은 메소드) ==> 반드시 구현!
						ccc(){}
						ddd(){}		// 추가
					}
					// 메모리 할당하는 방법
					B b = new B() => aaa(),bbb(),ccc(),ddd()
					A a = new B() => aaa(),bbb(),ccc()		=> ddd() 사용 불가
									 오버라이딩된 메소드를 호출한다
									 	abstract class A
									 	{
									 		aaa(){1}
									 		bbb(){2}
									 		abstract ccc()
									 	}
									 	class B extends A
									 	{
									 		aaa(){10}
									 		bbb(){20}
									 		ccc(){30}
									 		ddd(){40}
									 	}
									 	B b = new B();
									 	b.aaa() => 10
									 	b.bbb() => 20
									 	b.ccc() => 30
									 	b.ddd() => 40
									 	A a = new B();		// 변수는 클래스 A 안에 있는 것만 사용 가능하나 B 클래스의 메소드에 따라 값을 출력
									 	a.aaa()	=> b.aaa() ==> 10
									 	a.bbb() => b.bbb() ==> 20
									 	a.ccc() => b.ccc() ==> 30
									 	A c = new A(); => 오류 (메모리 할당이 불가능)
									 	* 추상클래스는 반드시 상속을 받아서 구현 후에 사용한다 : 오버라이딩 기법
			인터페이스
				interface A
				class B implements A
				{
					선언된 메소드를 구현해서 사용
				}
				=> 인터페이스도 상위클래스와 동일하게 취급
				A a = new B() => 인터페이스로 받아서 처리 => 여러 개를 묶어서 관리 목적
		= 인터페이스의 상속 과정
			interface == extends ==> interface
			interface == implements ==> class
			다중 상속
				interface A
				interface B	extends A
				interface C extends B
				
				interface A
				interface B
				interface C extends A,B
				
				interface A
				interface B
				class C implements A,B
				
				interface A
				interface B
				class C
				class D extends C implements A,B
		= 인터페이스의 default 메소드 (JDK 1.8~) : 구현이 된 메소드
			default 리턴형 메소드명(매개변수...)
			{
				구현
			}	==> 추상클래스 사용 빈도가 줄어들었다 (라이브러리에서는 아직 추상클래스를 사용 중)
	
	4) 예외처리
		= 예외처리 종류 (예외 복구, 예외 회피)
		= 자바에서 제공하는 예외처리 클래스 (계층 구조)
		= 실행 순서
		= 사용자정의 예외처리 ==> 호출 방법

	------------------------------------------- 자바 문법 사항
	
	라이브러리
		= Object, String, StringBuffer, Math, Wrapper ==> java.lang
		= StringTokenizer, Date, Calendar, SimpleDateFormat
		= List, Set, Map ==> java.util
		= IO

	------------------------------------------- 웹
	
	SQL => java.sql	***

	----------------------------------------------------------
	웹 관련 라이브러리 별도 다운로드


	오라클 HTML/CSS JavaScript JSP MVC Spring AWS
	++) JQuery(AJAX), VueJS(vuex vue3), MyBatis
	++) Spring-Boot, ReactJS, Redux, JPA, My-SQL




*/
public class MainClass_클래스 {

	public static void main(String[] args) {
		
	}
}
